---
title: 面向对象设计原则
date: 2019-07-31 20:22:33
tags: 
	- Java
	- 面向对象
	- 设计原则
categories:
	- Java设计模式
---

- 可维护性（Maintainability）
- 可复用性（Reusability）

----

<html>
<div style="text-align:center">
    <strong>
    7个常用的面向对象设计原则
    </strong>
</div>
</html>

| 设计原则名称                                         | 定义                                                         | 使用频率 |
| ---------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 单一职责原则（Single Responsibility Principle，SRP） | 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 | ★★★★☆    |
| 开闭原则（Open-Closed Principle，OCP）               | 软件实体应当对扩展开放，对修改关闭                           | ★★★★★    |
| 里氏代换原则（Liskov Substitution Principle，LSP）   | 所有引用基类的地方必须能透明地使用其子类的对象               | ★★★★★    |
| 依赖倒转原则（Dependece Inversion Principle，DIP）   | 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 | ★★★★★    |
| 接口隔离原则（Interface Segregation Principle，ISP） | 客户端不应该依赖那些它不需要的接口                           | ★★☆☆☆    |
| 合成复用原则（Composite Reuse Principle，CRP）       | 优先使用对象组合，而不是通过继承来达到复用目的               | ★★★★☆    |
| 迪米特法则（Law of Demeter，LoD）                    | 每一个软件单位对其他单位都只有最少的只是，而且局限于那些与本单位亲密相关的软件单位 | ★★★☆☆    |

<!-- more-->

### 单一职责原则

用于控制类的粒度大小。

是实现高内聚、低耦合的指导方针，它是最简单但有最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责则需要设计人员具有较强的分析能力和相关实践能力。

### 开闭原则

是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。

在开闭原则定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。开闭原则就是指软件实体应该尽量在不修改原有代码的情况下进行扩展。

### 里氏代换原则

如果对每一个类型为S的对象o1都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时程序P的行为没有变化，那么类型S是类型T的子类型。

里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不一定成立，如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。

里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类型，用子类对象来替换父类对象。


### 依赖倒转原则

如果说开闭原则是面向对象的设计目标，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。

依赖倒转原则要求程序代码中传递参数时或在关联关系中尽量引用高层次的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到子类中增加的新方法。

在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependence Injection，DI）的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象形式来注入所依赖的对象。

常用的注入方式有3种：
- 构造注入：通过构造函数来传入具体类的对象
- 设值注入：通过Setter方法来传入具体类的对象
- 接口注入：通过接口中声明的业务方法来传入具体类的对象

这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类来覆盖父类对象。

==**开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。**==

### 接口隔离原则

根据接口隔离原则，当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。

- 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以吧接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫“角色隔离原则”。
- 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。



### 合成复用原则

合成复用原则又称组合/聚合复用原则（Composition/Aggregate Reuse Principle,CARP）。

合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法来达到复用功能的目的。简而言之，在复用时要尽量使用组合/聚合关系（关联关系），少用继承。

### 迪米特法则

迪米特法则又称为最少知识法则（Least Knowledge Principle，LKP）。

迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

迪米特法则还有几种定义形式，包括不要和“陌生人”说话（don't talk to strangers），只与你的直接朋友通信（Talk only to immediate friends）等。

在迪米特法则中，对于一个对象，其朋友包括以下几类：
- 当前对象本身（this）
- 以参数形式传入到当前对象方法中对象
- 当前对象的成员对象
- 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友
- 当然对象所创建的对象。

任何一个对象如果满足以上面的条件之一，就时当前对象的“朋友”，否则就是“陌生人”。

在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。