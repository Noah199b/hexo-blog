---
title: 垃圾收集器（Garbage Collection，GC）与内存分配策略（四）
date: 2019-06-23 21:07:06
tags:
	- Java
	- Java虚拟机
	- JVM
	- 垃圾收集器（GC）
categories:
	- 深入理解Java虚拟机
---

## HotSpot算法实现

## 枚举根节点

从可达性分析中次部分GC Roots节点找引用链的操作为例，可作为GC Roots的节点主要是在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。

**可达性分析对执行时间的敏感还停留在GC停顿上**。<br>
因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来像被冻结在某个时间点上，不可以出现分析过程中对象引用关系海还在不断的发生变化的情况，该点不满足的话分析结果准确性就无法得到保证。<br>
这点是导致GC进行时必须停顿所有Java执行线程（Sun将这个事件称为“Stop The World”）的其中一个重要原因，即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

当执行系统停顿下来，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。<br>
在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。

<!-- more-->

## 安全点

OopMap可以协助快速完成枚举，但也可能导致引用关系发生变化，或者说OopMap内容变化的指令非常多，如果每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

在特定位置记录信息的点就称为安全点（Safepoint），即程序执行时并非在所有的地方都停顿下来开始GC，只有到达安全点时才能暂停。

**安全点的选定基本上是以程序“是否具备有让程序长时间执行的特征”为标准选定的**——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如：方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

- 抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动配合，在GC发生时，首先把所有的线程都中断，如果发现有线程中断的地方不再安全点，就恢复线程，让它“跑”到安全点上。**现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件**。
- 主动式中断（Voluntary Suspension）: 当GC需要中断线程的时候，不直接对线程操作，仅及简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方。

## 安全区域

Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。

程序不执行就是没有分配CPU时间，典型的例子就是线程出于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间，这种情况需要 **安全区域（Safe Regin）** 来解决。

**安全区域是指在一段代码片段中，引用关系不会发生变化**。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Regin 看做是被扩展的Safepoint。

当线程执行到安全区域时，首先标识自己已进入安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为“安全区域”状态的线程了，该线程只能乖乖的等待根节点枚举或者整个GC过程完成之后才能继续执行。

> 参考：https://blog.csdn.net/qq_41285600/article/details/82845989