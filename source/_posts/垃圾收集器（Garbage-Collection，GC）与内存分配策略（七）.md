---
title: 垃圾收集器（Garbage Collection，GC）与内存分配策略（七）
date: 2019-06-28 21:12:00
tags:
	- Java
	- Java虚拟机
	- JVM
	- 垃圾收集器（GC）
categories:
	- 深入理解Java虚拟机
---

### G1 收集器

G1 （Grabage-First） 收集器是当今收集器技术发展的最前沿成果之一。

G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK1.5发布的CMS收集器。

与其他GC收集器相比，G1具备以下特点：

- 并发与并行：G1能充分利用多CPU、多核环境下的硬件优势，使多个CPU(CPU或者CPU核心)来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍可以通过并发方式让Java程序继续执行。
- 分代收集：与其他收集器一样，分代概念G1中依然保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已存活了一段时间、熬过多次GC的就对象以获取更好的收集效果。
- 空间整合：与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会应为无法找到连续内存空间而提前触发下一次GC。
- 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器特征了。

使用G1收集器时，JAVA堆的内存布局就与其他收集器有很大的差别，它将整个堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。

在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。

G1中的每一个Regoion都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关的引用信息记录到被引用的对象所属的Region的Remembered Set中。当内存进行回收时，在GC根节点的枚举范围中加入Remembered Set即保证不对全堆扫描也不会有遗漏。

如果不计Remembered Set的操作，G1收集器大致可以分为以下几个步骤：

- 初始标记（Initial Marking）：标记GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这个阶段需要停顿线程，但耗时很短。
- 并发标记（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这个阶段耗时比较长，但可与用户程序 ==**并发**== 执行。
- 最终标记（Final Marking）：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在Remembered Set Logs里面，最终标记需要把Remebered Set Logs的数据合并到Remembered Set里，这个阶段需要停顿线程，但是可 ==**并行**==  执行。
- 筛选回收（Live Data Counting and Evacuation）：首先对Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段也可以做到与用户程序 ==**并发**== 执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。