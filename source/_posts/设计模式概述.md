---
title: 设计模式概述
date: 2019-07-29 20:50:29
tags: 
	- Java
	- 设计模式
---



名词：
- 模式（Pattern）

起源《建筑模式语言：城镇·建筑·构造》：
- Context （模式可适用的前提条件）
- Theme或Problem（在特定条件下要解决的目标问题）
- Solution（对目标问题求解过程中各物理关系的记述）

模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。<br>
A pattern is a successful or efficient solution to a recurring problem within a context.

软件模式与具体的应用领域无关，在模式发现过程中需要遵循大三律（Rule of Three），即只有经过3个以上不同类型（或不同领域）的系统的校验，一个解决方案才能从候选模式升格为模式。



<!-- more-->

## 设计模式的定义与分类

### 设计模式的定义

设计模式（Design Pattern）是一套被反复使用的、多事人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易的被他人理解并且提高代码的可靠性。设计模式是一种对于软件系统中不断重现的设计问题的解决方案进行文档化的技术，也是一种共享专家设计经验的技术。

> GoF对设计模式的定义如下：<br>
> 设计模式是在特定环境下为了解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。<br>
> Design pattern are decriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.

### 设计模式的基本要素

1. 模式名称（Pattern Name）
2. 问题（Problem）
3. 解决方案（Solution）
4. 效果（Consequences）

除了上述4个基本要素，在完整的设计模式描述中通常还包括：
- 模式的别名（其它名称）
- 模式的分类（模式所属类别）
- 模式的适用性（在什么情况下可以使用该设计模式）
- 模式角色（即模式参与者，模式的类和对象以及它们之间的职责）
- 模式实例（通过实例来进一步加深对模式的理解）
- 模式应用（在已有系统中该模式的使用）
- 模式扩展（该模式的一些改进、与之相关的其它模式及其它扩展知识）


### 设计模式的分类
1. 根据目的分类
    - 创建型（Creational）：主要用于创建对象
    - 结构性（Structural）：主要用于处理类或对象的组合
    - 行为型（Behavioral）：主要用于类或对象怎样交互或怎样分配职责
2. 根据范围分类
    - 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是一种静态关系。
    - 对象模式处理对象间的关系，这些关系在运行时变化，更具动态性。

## GoF设计模式

| 范围/目的 | 创建型模式                                         | 结构性模式                                                   | 行为型模式                                                   |
| --------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 类模式    | 工厂方法模式                                       | （类）适配器模式                                             | 解释器模式<br>模版方法模式                                   |
| 对象模式  | 抽象工厂模式<br>建造者模式<br>原型模式<br>单例模式 | （对象）适配器模式<br>桥接模式<br>组合模式<br>装饰模式<br>外观模式<br>享元模式<br>代理模式 | 职责链模式<br>命令模式<br>迭代器模式<br>中介者模式<br>备忘录模式<br>观察者模式<br>状态模式<br>策略模式<br>访问者模式 |



<html>
<table>
    <tr>
        <td width="200"><strong>模式类别</strong></td>
        <td width="280"><strong>模式名称</strong></td>
        <td><strong>模式说明</strong></td>
    </tr>
    <tr>
        <td rowspan="5">创建型模式<br>（Creational Patterns）</td>
        <td>抽象工厂模式<br>（Abstract Factory Pattern）</td>
        <td>提供一个创建一系列相关或相互依赖对象的接口，而无须指定具体的类</td>
    </tr>
    <tr>
        <td>建造者模式<br>（Builder Pattern）</td>
        <td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td>
    </tr>
    <tr>
        <td>工厂方法模式<br>（Factory Method Pattern）</td>
        <td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</td>
    </tr>
    <tr>
        <td>原型模式<br>（Prototype Pattern）</td>
        <td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</td>
    </tr>
    <tr>
        <td>单例模式<br>（Singleton Pattern）</td>
        <td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</td>
    </tr>
    <tr>
        <td rowspan="7">结构性模式<br>（Structural Patterns）</td>
        <td>适配器模式<br>（Adapter Pattern）</td>
        <td>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作</td>
    </tr>
    <tr>
        <td>桥接模式<br>（Bridge Pattern）</td>
        <td>将抽象与它的实现部分解耦，使得两者能够独立变化</td>
    </tr>
    <tr>
        <td>组合模式<br>（Composite Pattern）</td>
        <td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象</td>
    </tr>
    <tr>
        <td>装饰模式<br>（Decorator Pattern）</td>
        <td>动态的给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案</td>
    </tr>
    <tr>
        <td>外观模式<br>（Facade Pattern）</td>
        <td>为子系统的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td>
    </tr>
    <tr>
        <td>享元模式<br>（Flyweight Pattern）</td>
        <td>运用共享技术有效地支持大量细粒度对象的复用</td>
    </tr>
    <tr>
        <td>代理模式<br>（Proxy Pattern）</td>
        <td>给某一对象提供一个代理或占位符，并由代理对象来控制对原对象的访问</td>
    </tr>
    <tr>
        <td rowspan="11">行为模式<br>（Behavioral Patterns）</td>
        <td>职责链模式 <br>（Chain of Responsibility Pattern）</td>
        <td>避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接受请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止</td>
    </tr>
    <tr>
        <td>命令模式<br>（Command Pattern）</td>
        <td>将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</td>
    </tr>
    <tr>
        <td>解释器模式<br>（Interpreter Pattern）</td>
        <td>给定一个语言，定义它的文法的一种表示，表示定义一个解释器，这个解释器使用该表示来解释语言中的句子</td>
    </tr>
    <tr>
        <td>迭代器模式<br>（Iterator Pattern）</td>
        <td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td>
    </tr>
    <tr>
        <td>中介者模式<br>（Mediator Pattern）</td>
        <td>定义一个对象来封装一系列对象的交互。中介者模式使各个对象之间不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td>
    </tr>
    <tr>
        <td>备忘录模式<br>（Memento）</td>
        <td>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td>
    </tr>
    <tr>
        <td>观察者模式<br>（Observer Pattern）</td>
        <td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新</td>
    </tr>
    <tr>
        <td>状态模式<br>（State Pattern）</td>
        <td>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</td>
    </tr>
    <tr>
        <td>策略模式<br>（Strategy Pattern）</td>
        <td>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立使用它的客户而变化</td>
    </tr>
    <tr>
        <td>模版方法模式<br>（Template Method Pattern）</td>
        <td>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模版方法模式使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</td>
    </tr>
    <tr>
        <td>访问者模式<br>（Visitor Pattern）</td>
        <td>表示一个作用于某对象结构中的各个元素的操作。访问者模式可以在不改变各元素的类的前提下定义作用于这些元素的操作</td>
    </tr>
</table>
</html>